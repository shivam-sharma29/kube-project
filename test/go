#!/usr/bin/env bash

set -e
set -o pipefail

APP_NAME="tops-mdc"
TERRAFORM_DOCKER_IMAGE="hashicorp/terraform:0.12.8"

TASK=$1
ARGS=${@:2}

account_id_for_name() {
  case $1 in
  'cg-opsmo') echo "918810339200" ;;
  'cg-common') echo "491229787580" ;;
  'cg-poc') echo "062235833499" ;;
  'cg-sit') echo "515481116135" ;;
  'cg-tops-sit') echo "100170189736" ;;
  'cg-tops-ltest') echo "100170189736" ;;
  esac
}

assume_role() {
  local account_id="$1"
  local role="$2"

  local credentials=$(aws sts assume-role --role-arn "arn:aws:iam::${account_id}:role/${role}" \
    --role-session-name initial --duration-seconds 2700 | jq '.Credentials')
  export AWS_ACCESS_KEY_ID=$(echo "${credentials}" | jq -r .AccessKeyId)
  export AWS_SECRET_ACCESS_KEY=$(echo "${credentials}" | jq -r .SecretAccessKey)
  export AWS_SESSION_TOKEN=$(echo "${credentials}" | jq -r .SessionToken)
  unset AWS_SECURITY_TOKEN
}

assume_role_on_ospmo() {
  assume_role $(account_id_for_name "cg-opsmo") "GoCDAssumedIamRole"
}

assume_role_on_account() {
  local aws_account=$1
  assume_role $(account_id_for_name "${aws_account}") "terraform-app-deployer"
}

assume_role_on_aws_account_id() {
  local aws_account=$1
  assume_role "${aws_account}" "terraform-app-deployer"
}

runs_inside_gocd() {
  test -n "${GO_JOB_NAME}"
}

docker_ensure_volume() {
  docker volume inspect $1 >/dev/null 2>&1 || docker volume create $1 >/dev/null 2>&1
}

docker_ensure_network() {
  docker network inspect $1 >/dev/null 2>&1 || docker network create $1 >/dev/null 2>&1
}

docker_run() {
  if [ -z "${DOCKER_IMAGE}" ]; then
    echo -n "Building toolchain container; this might take a while..."
    DOCKER_IMAGE=$(docker build ${DOCKER_BUILD_ARGS} . -q)
    echo " Done."
  fi

  if runs_inside_gocd; then
    DOCKER_ARGS="${DOCKER_ARGS} -v godata:/godata -w $(pwd)"
  else
    DOCKER_ARGS="${DOCKER_ARGS} -it -v $(pwd):/workspace:cached -w /workspace"
  fi

  DOCKER_ARGS="${DOCKER_ARGS} -v ${HOME}/.aws:/root/.aws"
  docker_ensure_network magento_network
  docker run --rm \
    --hostname $(hostname) \
    --net magento_network \
    --env-file <(env | grep AWS_) \
    --env-file <(env | grep TF_) \
    ${DOCKER_ARGS} ${DOCKER_IMAGE} "$@"
}

tf() {
  if runs_inside_gocd; then
    local docker_user_args="-u $(id -u)"
  else
    local docker_user_args="-u $(id -u)"
  fi

  DOCKER_IMAGE="${TERRAFORM_DOCKER_IMAGE}"
  DOCKER_ARGS="${DOCKER_ARGS} ${docker_user_args}"

  docker_run "$@"
}

build_fetch_secret() {
  (
    account_name="$1"
    role_name="$2"
    secret_name="$3"
    assume_role "${account_name}" "${role_name}"
    echo $(aws secretsmanager get-secret-value --secret-id ${secret_name} --query SecretString --output text --region ap-southeast-1)
  )
}

build_fetch_secret_to_file() {
  (
    account_name="$1"
    role_name="$2"
    secret_name="$3"
    file_name="$4"
    assume_role "${account_name}" "${role_name}"
    aws secretsmanager get-secret-value --secret-id ${secret_name} --query SecretString --output text --region ap-southeast-1 >$file_name
  )
}

build_fetch_secret_pem() {
  (
    account_name="$1"
    role_name="$2"
    secret_name="$3"
    assume_role "${account_name}" "${role_name}"
    aws secretsmanager get-secret-value --secret-id ${secret_name} --query SecretString --output text --region ap-southeast-1 >servers_key.pem
  )
}

help__zipCurrentFolder="Zip current  MDC folder for transfet between GoCD stage since folder size is very large"
task_zipCurrentFolder() {
  zip -r MagentoCI.zip .
}

help__unzipMagentoCI="Unzip MagentoCI.zip in current folder"
task_unzipMagentoCI() {
  unzip -o MagentoCI.zip
  rm MagentoCI.zip
}

help__mdcDeploy="TOPS MDC Ansible deploy"
task_mdcDeploy() {
  local env=${1}
  local artifact=${2}
  local api_deploy=${3}

  local UPSTREAM_PIPELINE_COUNTER=${GO_DEPENDENCY_LABEL_TOPS_MDC_BUILD_PIPELINE}
  echo ${UPSTREAM_PIPELINE_COUNTER}
  if [ -z "${env}" ]; then
    echo "Needs environment"
    exit 1
  fi
  set -- "$ARGS"
  cd ./ansible
  mkdir -p templates

  # Load configuration files from secrets manager
  build_fetch_secret_to_file $(account_id_for_name "cg-tops-${env}") "gocd-mdc-deployer-assume-role" "${env}/mdc/tops/auth_shared" "./templates/auth_shared.json"
  build_fetch_secret_to_file $(account_id_for_name "cg-tops-${env}") "gocd-mdc-deployer-assume-role" "${env}/mdc/tops/env_php" "./templates/env.php.j2"
  build_fetch_secret_to_file $(account_id_for_name "cg-tops-${env}") "gocd-mdc-deployer-assume-role" "${env}/mdc/tops/nginx_shared_conf" "./templates/nginx_shared.conf.j2"
  build_fetch_secret_pem $(account_id_for_name "cg-tops-${env}") "gocd-mdc-deployer-assume-role" "${env}/mdc/tops/servers_key"

  local ENV_SECRET=$(build_fetch_secret $(account_id_for_name "cg-tops-${env}") "gocd-mdc-deployer-assume-role" "${env}/mdc/tops/secrets")
  local DATABASE_PASSWORD=$(echo "${ENV_SECRET}" | jq -r .DATABASE_PASSWORD)
  local OAUTH_CLIENT_SECRET=$(echo "${ENV_SECRET}" | jq -r .OAUTH_CLIENT_SECRET)
  chmod 400 servers_key.pem
  local NEXUS_SECRETS=$(build_fetch_secret $(account_id_for_name "cg-tops-${env}") "gocd-mdc-deployer-assume-role" "mdc-build/nexus_auth")
  local NEXUS_KEY=$(echo "${NEXUS_SECRETS}" | jq -r .NEXUS_PUSH_AUTH)
  ansible-galaxy install ansistrano.deploy ansistrano.rollback

  mdc_artifact_url="https://nexus.central.tech/repository/tops-mdc/${artifact}/GoCD/${UPSTREAM_PIPELINE_COUNTER}/MagentoCI.zip"

  echo "deploying mdc artefact version ${UPSTREAM_PIPELINE_COUNTER} from ${mdc_artifact_url}"
  if [ -z "${api_deploy}" ]; then
     echo "${api_deploy} -  deploy normal"
     ansible-playbook -i ${env}-hosts.ini deploy.yml --private-key servers_key.pem --extra-var "ansistrano_download_force_basic_auth=true ansistrano_download_headers=\"Authorization:Basic ${NEXUS_KEY}\" ansistrano_get_url=${mdc_artifact_url} ansistrano_deploy_from=../ ansistrano_allow_anonymous_stats=no  argument_deploy=${ARGUMENT}"
  else 
     echo "${api_deploy} -  deploy api only"
     ansible-playbook -i ${api_deploy}-hosts.ini deploy-api.yml --private-key servers_key.pem --extra-var "ansistrano_download_force_basic_auth=true ansistrano_download_headers=\"Authorization:Basic ${NEXUS_KEY}\" ansistrano_get_url=${mdc_artifact_url} ansistrano_deploy_from=../ ansistrano_allow_anonymous_stats=no argument_deploy=${ARGUMENT}"
  fi
  
  # remove env.php file from go-agent
  rm -f ./templates/env.php.j2
}

help__mdcRollback="TOPS MDC Ansible rollback"
task_mdcRollback() {
  local env=${1}
  cd ./ansible
  build_fetch_secret_pem $(account_id_for_name "cg-tops-${env}") "gocd-mdc-deployer-assume-role" "${env}/mdc/tops/servers_key"
  chmod 400 servers_key.pem
  ansible-playbook -i ${env}-hosts.ini rollback.yml --private-key servers_key.pem
}

help__mdcSchedule="TOPS MDC Scheduling Automation pipelines"
task_mdcSchedule() {
  local env=${1}
  local pipeline_env1=${2}
  local pipeline_env2=${3}
  local pipeline_env3=${4}
  local pipeline_env4=${5}
  local pipeline_env5=${6}

  if [ -z "${env}" ]; then
    echo "Needs environment"
    exit 1
  fi
  set -- "$ARGS"

  # load GOCD API KEY
  local GOCD_SECRETS=$(build_fetch_secret $(account_id_for_name "cg-tops-${env}") "gocd-mdc-deployer-assume-role" "mdc-deploy/gocd_api_key")
  local GOCD_API_KEY=$(echo "${GOCD_SECRETS}" | jq -r .GOCD_API_KEY)  
  #GOCD_API_KEY="5db761b00164a371dc7aa3b0a6940f16841f7a8c" 

  # Trigger pipeline
  curl -X POST "https://gocd.opsmo.central.tech/go/api/pipelines/${pipeline_env1}/schedule" \
  -H "Authorization: Bearer ${GOCD_API_KEY}" \
  -H "Accept: application/vnd.go.cd.v1+json" \
  -H "X-GoCD-Confirm: true" \
  -H "Content-Type: application/json"
 
#  curl -X POST "https://gocd.opsmo.central.tech/go/api/pipelines/${pipeline_env2}/schedule" \
#  -H "Authorization: Bearer ${GOCD_API_KEY}" \
#  -H "Accept: application/vnd.go.cd.v1+json" \
#  -H "X-GoCD-Confirm: true" \
#  -H "Content-Type: application/json"
#
#  curl -X POST "https://gocd.opsmo.central.tech/go/api/pipelines/${pipeline_env3}/schedule" \
#  -H "Authorization: Bearer ${GOCD_API_KEY}" \
#  -H "Accept: application/vnd.go.cd.v1+json" \
#  -H "X-GoCD-Confirm: true" \
#  -H "Content-Type: application/json"
#
#  curl -X POST "https://gocd.opsmo.central.tech/go/api/pipelines/${pipeline_env4}/schedule" \
#  -H "Authorization: Bearer ${GOCD_API_KEY}" \
#  -H "Accept: application/vnd.go.cd.v1+json" \
#  -H "X-GoCD-Confirm: true" \
#  -H "Content-Type: application/json"
#
#  curl -X POST "https://gocd.opsmo.central.tech/go/api/pipelines/${pipeline_env5}/schedule" \
#  -H "Authorization: Bearer ${GOCD_API_KEY}" \
#  -H "Accept: application/vnd.go.cd.v1+json" \
#  -H "X-GoCD-Confirm: true" \
#  -H "Content-Type: application/json"
}

help__mdcScheduleRollback="TOPS MDC Scheduling Rollback pipelines"
task_mdcScheduleRollback() {
  local env=${1}
  local pipeline_env=${2}

  # load GOCD API KEY
  #local GOCD_SECRETS=$(build_fetch_secret $(account_id_for_name "cg-tops-${env}") "gocd-mdc-deployer-assume-role" "mdc-deploy/gocd_api_key")
  #local GOCD_API_KEY=$(echo "${GOCD_SECRETS}" | jq -r .GOCD_API_KEY)
  GOCD_API_KEY="5db761b00164a371dc7aa3b0a6940f16841f7a8c"

  # Trigger pipeline
  curl -X POST "https://gocd.opsmo.central.tech/go/api/pipelines/${pipeline_env}/schedule" \
  -H "Authorization: Bearer ${GOCD_API_KEY}" \
  -H "Accept: application/vnd.go.cd.v1+json" \
  -H "X-GoCD-Confirm: true" \
  -H "Content-Type: application/json"
}

help__mdcStopInstance="TOPS MDC Stop Instance pipelines"
task_mdcStopInstance() {
  local ACCOUNT_ID="$1"
  local INSTANCE_ID="$2"
  local REGION="$3"

  #assume_role_on_aws_account_id "${ACCOUNT_ID}"
  export AWS_DEFAULT_REGION="${REGION}"
  
  INSTANCE_STATE=$(aws ec2 describe-instances --instance-id "${INSTANCE_ID}" --query 'Reservations[*].Instances[*].State[].Name' --output text)
  echo ${INSTANCE_STATE}
  if [ $INSTANCE_STATE == "running" ]; then
    echo "Stop EC2 instance"
    aws ec2 stop-instances --instance-ids "${INSTANCE_ID}"
    echo "Stop instances succeed"
  fi
}

help__mdcStartInstance="TOPS MDC Start Instance pipelines"
task_mdcStartInstance() {
  local ACCOUNT_ID="$1"
  local INSTANCE_ID="$2"
  local REGION="$3"

  #assume_role_on_aws_account_id "${ACCOUNT_ID}"
  export AWS_DEFAULT_REGION="${REGION}"

  INSTANCE_STATE=$(aws ec2 describe-instances --instance-id "${INSTANCE_ID}" --query 'Reservations[*].Instances[*].State[].Name' --output text)
  echo ${INSTANCE_STATE}
  if [ $INSTANCE_STATE == "stopped" ]; then
    echo "Start EC2 instance"
    aws ec2 start-instances --instance-ids "${INSTANCE_ID}"
    echo "Start instances succeed"
  fi
}

help__mdcStopRDS="TOPS MDC Stop RDS pipelines"
task_mdcStopRDS() {
  local ACCOUNT_ID="$1"
  local RDS_ID="$2"
  local REGION="$3"

  #assume_role_on_aws_account_id "${ACCOUNT_ID}"
  export AWS_DEFAULT_REGION="${REGION}"

  DB_INSTANCE_STATE=$(aws rds describe-db-instances --db-instance-identifier "${RDS_ID}" --query DBInstances[*].DBInstanceStatus --output text)
  echo ${DB_INSTANCE_STATE}
  if [ $DB_INSTANCE_STATE != "stopped" ]; then
    echo "Stop DB instance"
    aws rds stop-db-instance --db-instance-identifier "${RDS_ID}"
    echo "Stop DB instances succeed"
  fi
}

help__mdcStartRDS="TOPS MDC Start RDS pipelines"
task_mdcStartRDS() {
  local ACCOUNT_ID="$1"
  local RDS_ID="$2"
  local REGION="$3"

  #assume_role_on_aws_account_id "${ACCOUNT_ID}"
  export AWS_DEFAULT_REGION="${REGION}"

  DB_INSTANCE_STATE=$(aws rds describe-db-instances --db-instance-identifier "${RDS_ID}" --query DBInstances[*].DBInstanceStatus --output text)
  echo ${DB_INSTANCE_STATE}
  if [ $DB_INSTANCE_STATE == "stopped" ]; then
    echo "Start DB instance"
    aws rds start-db-instance --db-instance-identifier "${RDS_ID}"
    echo "Start DB instances succeed"
  fi
}

help__mdcAsgScale="TOPS MDC ASG Scale pipelines"
task_mdcAsgScale() {
  local ACCOUNT_ID="$1"
  local ASG_NAME="$2"
  local REGION="$3"
  local MIN_SIZE="$4"
  local MAX_SIZE="$5"
  local DESIRED_CAPACITY="$6"

  #assume_role_on_aws_account_id "${ACCOUNT_ID}"
  export AWS_DEFAULT_REGION="${REGION}"
  echo "Start ASG scale"
  aws autoscaling update-auto-scaling-group --auto-scaling-group-name ${ASG_NAME} --min-size ${MIN_SIZE} --max-size ${MAX_SIZE} --desired-capacity ${DESIRED_CAPACITY}
 
  # Determine scaling parameters
  ORIGINAL_ASG_MIN_SIZE=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name "${ASG_NAME}" --query AutoScalingGroups[].MinSize --output text)
  ORIGINAL_ASG_MAX_SIZE=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name "${ASG_NAME}" --query AutoScalingGroups[].MaxSize --output text)
  ORIGINAL_ASG_DESIRED_CAPACITY=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name "${ASG_NAME}" --query AutoScalingGroups[].DesiredCapacity --output text)
  echo "ORIGINAL_ASG_MIN_SIZE=${ORIGINAL_ASG_MIN_SIZE}"
  echo "ORIGINAL_ASG_MAX_SIZE=${ORIGINAL_ASG_MAX_SIZE}"
  echo "ORIGINAL_ASG_DESIRED_CAPACITY=${ORIGINAL_ASG_DESIRED_CAPACITY}"
  if [[ ${ORIGINAL_ASG_MIN_SIZE} -eq ${MIN_SIZE} && ${ORIGINAL_ASG_MAX_SIZE} -eq ${MAX_SIZE} && ${ORIGINAL_ASG_DESIRED_CAPACITY} -eq ${DESIRED_CAPACITY} ]]; then
    echo "ASG scale succeed"
    exit 0
  else
    echo "ASG scale failed"
    exit 1
  fi
}

help__mdcRedisScale="TOPS MDC Redis Scale pipelines"
task_mdcRedisScale() {
  local ACCOUNT_ID="$1"
  local CLUSTER_ID="$2"
  local REGION="$3"
  local NODE_TYPE="$4"
  local DESIRED_CAPACITY="$5"
  local REPICATION_GROUP="$6"

  #assume_role_on_aws_account_id "${ACCOUNT_ID}"
  export AWS_DEFAULT_REGION="${REGION}"
  echo "Start Redis scale up and out"
  if [ $REPICATION_GROUP == "no" ]; then 
    aws elasticache modify-cache-cluster --cache-cluster-id ${CLUSTER_ID} --num-cache-nodes ${DESIRED_CAPACITY} --cache-node-type ${NODE_TYPE} --apply-immediately
    
    sleep 180
    # Determine scaling parameters
    CACHE_NODE_TYPE=$(aws elasticache describe-cache-clusters --cache-cluster-id ${CLUSTER_ID} --query CacheClusters[].CacheNodeType --output text)
    CACHE_NODE_NUM=$(aws elasticache describe-cache-clusters --cache-cluster-id ${CLUSTER_ID} --query CacheClusters[].NumCacheNodes --output text)
    echo "CacheNodeType=${CACHE_NODE_TYPE}"
    echo "NumCacheNodes=${CACHE_NODE_NUM}"
    if [[ ${CACHE_NODE_TYPE} == ${NODE_TYPE} && ${CACHE_NODE_NUM} -eq ${DESIRED_CAPACITY} ]]; then
      echo "Redis scale succeed"
      exit 0
    else
      echo "Redis scale failed"
      exit 1
    fi
  else
    aws elasticache modify-replication-group --replication-group-id ${CLUSTER_ID} --cache-node-type ${NODE_TYPE} --apply-immediately
    

    sleep 180
    # Determine scaling parameters
    CACHE_NODE_TYPE=$(aws elasticache describe-replication-groups --replication-group-id ${CLUSTER_ID} --query ReplicationGroups[].CacheNodeType --output text)
    echo "CacheNodeType=${CACHE_NODE_TYPE}"
    if [ ${CACHE_NODE_TYPE} == ${NODE_TYPE} ]; then
      echo "Redis scale succeed"
      exit 0
    else
      echo "Redis scale failed"
      exit 1
    fi
  fi
}

help__asgCreateSnapshot="Create snapshot for ASG deployment"
task_asgCreateSnapshot() {
  echo "Start create snapshot"

  local ACCOUNT_ID="$1"
  local INSTANCE_ID="$2"
  local INSTANCE_NAME="$3"
  local LAUNCH_TEMPLATE_ID="$4"
  local ASG_NAME="$5"
  local ROLE_NAME="$6"
  local REGION="$7"

  local IMAGE_ID
  local SNAPSHOT_ID

  assume_role_on_aws_account_id "${ACCOUNT_ID}"
  export AWS_DEFAULT_REGION="${REGION}"

  #create timestamp
  local timestamp=$(date +%s)

  local AMI_BUILD_TIMESTAMP=${timestamp}

  IMAGE_ID=$(aws ec2 create-image --instance-id "${INSTANCE_ID}" --name "${INSTANCE_NAME}"-image-at-"${AMI_BUILD_TIMESTAMP}" --description "Snapshot of ${INSTANCE_NAME} taken at ${AMI_BUILD_TIMESTAMP}" --no-reboot --output text)
  aws ec2 wait image-available --image-ids "${IMAGE_ID}"
  aws ec2 create-tags --resources "${IMAGE_ID}" --tags Key=Name,Value="${INSTANCE_NAME}"-image-at-"${AMI_BUILD_TIMESTAMP}"
  SNAPSHOT_ID=$(aws ec2 describe-images --owners "${ACCOUNT_ID}" --image-ids "${IMAGE_ID}" --query "Images[].BlockDeviceMappings[?DeviceName=='/dev/xvda'].Ebs.SnapshotId" --output text)
  aws ec2 create-tags --resources "${SNAPSHOT_ID}" --tags Key=Name,Value=${APP_NAME}-asg-snapshot

  # Passing variables
  echo "IMAGE_ID=${IMAGE_ID}" >${APP_NAME}-snapshot.info
  echo "SNAPSHOT_ID=${SNAPSHOT_ID}" >>${APP_NAME}-snapshot.info
  echo "ACCOUNT_ID=${ACCOUNT_ID}" >>${APP_NAME}-snapshot.info
  echo "INSTANCE_ID=${INSTANCE_ID}" >>${APP_NAME}-snapshot.info
  echo "INSTANCE_NAME=${INSTANCE_NAME}" >>${APP_NAME}-snapshot.info
  echo "AMI_BUILD_TIMESTAMP=${AMI_BUILD_TIMESTAMP}" >>${APP_NAME}-snapshot.info
  echo "LAUNCH_TEMPLATE_ID=${LAUNCH_TEMPLATE_ID}" >>${APP_NAME}-snapshot.info
  echo "ASG_NAME=${ASG_NAME}" >>${APP_NAME}-snapshot.info
  echo "ROLE_NAME=${ROLE_NAME}" >>${APP_NAME}-snapshot.info
  echo "AWS_DEFAULT_REGION=${REGION}" >>${APP_NAME}-snapshot.info

  # debug outcome of info file
  cat ${APP_NAME}-snapshot.info
}

help__asgUpdateLaunchTemplate="Update launch template for ASG deployment"
task_asgUpdateLaunchTemplate() {
  echo "Update Launch Template"
  ls -lah
  # debug outcome of info file
  cat ${APP_NAME}-snapshot.info
  # Import ASG variables
  source ${APP_NAME}-snapshot.info
  assume_role_on_aws_account_id "${ACCOUNT_ID}"
  export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION}"
  aws ec2 create-launch-template-version --launch-template-id "${LAUNCH_TEMPLATE_ID}" --source-version "\$Latest" --version-description "Launch template for the ASG based on ${INSTANCE_NAME}" --launch-template-data "{\"ImageId\":\"${IMAGE_ID}\"}"
}

help__asgPrepareForScalingOut="Prepare for scaling out ASG"
task_asgPrepareForScalingOut() {
  echo "Prepare for scaling out ASG"

  # Import ASG variables
  source ${APP_NAME}-snapshot.info
  export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION}"
  assume_role_on_aws_account_id "${ACCOUNT_ID}"

  # Determine scaling parameters
  ORIGINAL_ASG_MIN_SIZE=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name "${ASG_NAME}" --query AutoScalingGroups[].MinSize --output text)
  ORIGINAL_ASG_MAX_SIZE=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name "${ASG_NAME}" --query AutoScalingGroups[].MaxSize --output text)
  ORIGINAL_ASG_DESIRED_CAPACITY=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name "${ASG_NAME}" --query AutoScalingGroups[].DesiredCapacity --output text)
  echo "ORIGINAL_ASG_MIN_SIZE=${ORIGINAL_ASG_MIN_SIZE}"
  echo "ORIGINAL_ASG_MAX_SIZE=${ORIGINAL_ASG_MAX_SIZE}"
  echo "ORIGINAL_ASG_DESIRED_CAPACITY=${ORIGINAL_ASG_DESIRED_CAPACITY}"

  TEMP_ASG_MIN_SIZE=$(($ORIGINAL_ASG_MIN_SIZE * 2))
  TEMP_ASG_MAX_SIZE=$(($ORIGINAL_ASG_MAX_SIZE * 2))
  TEMP_ASG_DESIRED_CAPACITY=$(($ORIGINAL_ASG_DESIRED_CAPACITY * 2))

  echo "TEMP_ASG_MIN_SIZE=${TEMP_ASG_MIN_SIZE}"
  echo "TEMP_ASG_MAX_SIZE=${TEMP_ASG_MAX_SIZE}"
  echo "TEMP_ASG_DESIRED_CAPACITY=${TEMP_ASG_DESIRED_CAPACITY}"
  echo "ORIGINAL_ASG_MIN_SIZE=${ORIGINAL_ASG_MIN_SIZE}" >>${APP_NAME}-snapshot.info
  echo "ORIGINAL_ASG_MAX_SIZE=${ORIGINAL_ASG_MAX_SIZE}" >>${APP_NAME}-snapshot.info
  echo "ORIGINAL_ASG_DESIRED_CAPACITY=${ORIGINAL_ASG_DESIRED_CAPACITY}" >>${APP_NAME}-snapshot.info
  echo "TEMP_ASG_MIN_SIZE=${TEMP_ASG_MIN_SIZE}" >>${APP_NAME}-snapshot.info
  echo "TEMP_ASG_MAX_SIZE=${TEMP_ASG_MAX_SIZE}" >>${APP_NAME}-snapshot.info
  echo "TEMP_ASG_DESIRED_CAPACITY=${TEMP_ASG_DESIRED_CAPACITY}" >>${APP_NAME}-snapshot.info

  # Protect the new instances from scaling in
  aws autoscaling update-auto-scaling-group --auto-scaling-group-name ${ASG_NAME} --new-instances-protected-from-scale-in
}

help__asgPrepareForScalingOutLTE="Prepare for scaling out LTE ASG"
task_asgPrepareForScalingOutLTE() {
  echo "Prepare for scaling out LTE ASG"

  local ACCOUNT_ID="$1"
  local ASG_NAME="$2"
  local ROLE_NAME="$3"
  local REGION="$4"

  assume_role_on_aws_account_id "${ACCOUNT_ID}"

  # Passing variables
  echo "ACCOUNT_ID=${ACCOUNT_ID}" >${APP_NAME}-snapshot.info
  echo "ASG_NAME=${ASG_NAME}" >>${APP_NAME}-snapshot.info
  echo "ROLE_NAME=${ROLE_NAME}" >>${APP_NAME}-snapshot.info
  echo "AWS_DEFAULT_REGION=${REGION}" >>${APP_NAME}-snapshot.info

  # Import ASG variables
  source ${APP_NAME}-snapshot.info
  export AWS_DEFAULT_REGION="${REGION}"
  

  # Determine scaling parameters
  ORIGINAL_ASG_MIN_SIZE=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name "${ASG_NAME}" --query AutoScalingGroups[].MinSize --output text)
  ORIGINAL_ASG_MAX_SIZE=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name "${ASG_NAME}" --query AutoScalingGroups[].MaxSize --output text)
  ORIGINAL_ASG_DESIRED_CAPACITY=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name "${ASG_NAME}" --query AutoScalingGroups[].DesiredCapacity --output text)
  echo "ORIGINAL_ASG_MIN_SIZE=${ORIGINAL_ASG_MIN_SIZE}"
  echo "ORIGINAL_ASG_MAX_SIZE=${ORIGINAL_ASG_MAX_SIZE}"
  echo "ORIGINAL_ASG_DESIRED_CAPACITY=${ORIGINAL_ASG_DESIRED_CAPACITY}"

  TEMP_ASG_MIN_SIZE=30
  TEMP_ASG_MAX_SIZE=60
  TEMP_ASG_DESIRED_CAPACITY=30

  echo "TEMP_ASG_MIN_SIZE=${TEMP_ASG_MIN_SIZE}"
  echo "TEMP_ASG_MAX_SIZE=${TEMP_ASG_MAX_SIZE}"
  echo "TEMP_ASG_DESIRED_CAPACITY=${TEMP_ASG_DESIRED_CAPACITY}"
  echo "ORIGINAL_ASG_MIN_SIZE=${ORIGINAL_ASG_MIN_SIZE}" >>${APP_NAME}-snapshot.info
  echo "ORIGINAL_ASG_MAX_SIZE=${ORIGINAL_ASG_MAX_SIZE}" >>${APP_NAME}-snapshot.info
  echo "ORIGINAL_ASG_DESIRED_CAPACITY=${ORIGINAL_ASG_DESIRED_CAPACITY}" >>${APP_NAME}-snapshot.info
  echo "TEMP_ASG_MIN_SIZE=${TEMP_ASG_MIN_SIZE}" >>${APP_NAME}-snapshot.info
  echo "TEMP_ASG_MAX_SIZE=${TEMP_ASG_MAX_SIZE}" >>${APP_NAME}-snapshot.info
  echo "TEMP_ASG_DESIRED_CAPACITY=${TEMP_ASG_DESIRED_CAPACITY}" >>${APP_NAME}-snapshot.info

  # Protect the new instances from scaling in
  aws autoscaling update-auto-scaling-group --auto-scaling-group-name ${ASG_NAME} --new-instances-protected-from-scale-in
}

help__asgScalingOut="Scaling out ASG"
task_asgScalingOut() {
  echo "Scaling out ASG"

  # Import ASG variables
  source ${APP_NAME}-snapshot.info
  export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION}"
  assume_role_on_aws_account_id "${ACCOUNT_ID}"
  aws autoscaling update-auto-scaling-group --auto-scaling-group-name ${ASG_NAME} --min-size ${TEMP_ASG_MIN_SIZE} --max-size ${TEMP_ASG_MAX_SIZE} --desired-capacity ${TEMP_ASG_DESIRED_CAPACITY}
}

help__asgWaitForScalingOutToComplete="Wait for scaling out to complete"
task_asgWaitForScalingOutToComplete() {
  echo "Wait for scaling out to complete"
  # Import ASG variables
  source ${APP_NAME}-snapshot.info
  cat ${APP_NAME}-snapshot.info
  export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION}"
  assume_role_on_aws_account_id "${ACCOUNT_ID}"
  local CURRENT_CAPACITY
  CURRENT_CAPACITY=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name ${ASG_NAME} --query "AutoScalingGroups[].Instances[?HealthStatus == 'Healthy' && LifecycleState == 'InService'].InstanceId[] | length(@)")
  echo "CURRENT_CAPACITY=${CURRENT_CAPACITY}"
  echo "TEMP_ASG_DESIRED_CAPACITY=${TEMP_ASG_DESIRED_CAPACITY}"
  while [ "${CURRENT_CAPACITY}" != ${TEMP_ASG_DESIRED_CAPACITY} ]; do
    sleep 7
    CURRENT_CAPACITY=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name ${ASG_NAME} --query "AutoScalingGroups[].Instances[?HealthStatus == 'Healthy' && LifecycleState == 'InService'].InstanceId[] | length(@)")
    echo "CURRENT_CAPACITY=${CURRENT_CAPACITY}"
  done
  echo "Scaling out succeed"
}

help__asgPrepareForScalingInLTE="Prepare for scaling in LTE ASG"
task_asgPrepareForScalingInLTE() {
  echo "Prepare for scaling in ASG"

  local ACCOUNT_ID="$1"
  local ASG_NAME="$2"
  local ROLE_NAME="$3"
  local REGION="$4"
  
  assume_role_on_aws_account_id "${ACCOUNT_ID}"

  # Passing variables
  echo "ACCOUNT_ID=${ACCOUNT_ID}" >${APP_NAME}-snapshot.info
  echo "ASG_NAME=${ASG_NAME}" >>${APP_NAME}-snapshot.info
  echo "ROLE_NAME=${ROLE_NAME}" >>${APP_NAME}-snapshot.info
  echo "AWS_DEFAULT_REGION=${REGION}" >>${APP_NAME}-snapshot.info
  
  # Import ASG variables
  source ${APP_NAME}-snapshot.info
  export AWS_DEFAULT_REGION="${REGION}"
  assume_role_on_aws_account_id "${ACCOUNT_ID}"

  # Determine scaling parameters
  ORIGINAL_ASG_MIN_SIZE=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name "${ASG_NAME}" --query AutoScalingGroups[].MinSize --output text)
  ORIGINAL_ASG_MAX_SIZE=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name "${ASG_NAME}" --query AutoScalingGroups[].MaxSize --output text)
  ORIGINAL_ASG_DESIRED_CAPACITY=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name "${ASG_NAME}" --query AutoScalingGroups[].DesiredCapacity --output text)
  echo "ORIGINAL_ASG_MIN_SIZE=${ORIGINAL_ASG_MIN_SIZE}"
  echo "ORIGINAL_ASG_MAX_SIZE=${ORIGINAL_ASG_MAX_SIZE}"
  echo "ORIGINAL_ASG_DESIRED_CAPACITY=${ORIGINAL_ASG_DESIRED_CAPACITY}"

  TEMP_ASG_MIN_SIZE=1
  TEMP_ASG_MAX_SIZE=60
  TEMP_ASG_DESIRED_CAPACITY=1

  echo "TEMP_ASG_MIN_SIZE=${TEMP_ASG_MIN_SIZE}"
  echo "TEMP_ASG_MAX_SIZE=${TEMP_ASG_MAX_SIZE}"
  echo "TEMP_ASG_DESIRED_CAPACITY=${TEMP_ASG_DESIRED_CAPACITY}"
  echo "ORIGINAL_ASG_MIN_SIZE=${ORIGINAL_ASG_MIN_SIZE}" >>${APP_NAME}-snapshot.info
  echo "ORIGINAL_ASG_MAX_SIZE=${ORIGINAL_ASG_MAX_SIZE}" >>${APP_NAME}-snapshot.info
  echo "ORIGINAL_ASG_DESIRED_CAPACITY=${ORIGINAL_ASG_DESIRED_CAPACITY}" >>${APP_NAME}-snapshot.info
  echo "TEMP_ASG_MIN_SIZE=${TEMP_ASG_MIN_SIZE}" >>${APP_NAME}-snapshot.info
  echo "TEMP_ASG_MAX_SIZE=${TEMP_ASG_MAX_SIZE}" >>${APP_NAME}-snapshot.info
  echo "TEMP_ASG_DESIRED_CAPACITY=${TEMP_ASG_DESIRED_CAPACITY}" >>${APP_NAME}-snapshot.info

  # Protect the new instances from scaling in
  aws autoscaling update-auto-scaling-group --auto-scaling-group-name ${ASG_NAME} --new-instances-protected-from-scale-in
}

help__asgScalingIn="Scaling in"
task_asgScalingIn() {
  echo "Scaling in"
  cat ${APP_NAME}-snapshot.info
  # Import ASG variables
  source ${APP_NAME}-snapshot.info
  export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION}"
  assume_role_on_aws_account_id "${ACCOUNT_ID}"
  aws autoscaling update-auto-scaling-group --auto-scaling-group-name ${ASG_NAME} --min-size ${ORIGINAL_ASG_MIN_SIZE} --max-size ${ORIGINAL_ASG_MAX_SIZE} --desired-capacity ${ORIGINAL_ASG_DESIRED_CAPACITY}
}

help__asgWaitForScalingInToComplete="Wait for scaling in to complete"
task_asgWaitForScalingInToComplete() {
  echo "Wait for scaling in to complete"

  # Import ASG variables
  source ${APP_NAME}-snapshot.info
  cat ${APP_NAME}-snapshot.info
  export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION}"
  assume_role_on_aws_account_id "${ACCOUNT_ID}"
  local CURRENT_CAPACITY
  CURRENT_CAPACITY=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name ${ASG_NAME} --query "AutoScalingGroups[].Instances[?HealthStatus == 'Healthy' && LifecycleState == 'InService'].InstanceId[] | length(@)")
  echo "CURRENT_CAPACITY=${CURRENT_CAPACITY}"
  echo "ORIGINAL_ASG_DESIRED_CAPACITY=${ORIGINAL_ASG_DESIRED_CAPACITY}"
  while [ ${CURRENT_CAPACITY} != ${ORIGINAL_ASG_DESIRED_CAPACITY} ]; do
    sleep 7
    CURRENT_CAPACITY=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name ${ASG_NAME} --query "AutoScalingGroups[].Instances[?HealthStatus == 'Healthy' && LifecycleState == 'InService'].InstanceId[] | length(@)")
    echo "CURRENT_CAPACITY=${CURRENT_CAPACITY}"
  done
  echo "Scaling in succeed"
}

help__asgRestoreOriginalStateAfterScalingIn="Restore original state after scaling in"
task_asgRestoreOriginalStateAfterScalingIn() {
  echo "Restore original state after scaling in"
  local PROTECTED_INSTANCE_IDS

  # Import ASG variables
  source ${APP_NAME}-snapshot.info
  cat ${APP_NAME}-snapshot.info
  export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION}"
  assume_role_on_aws_account_id "${ACCOUNT_ID}"
  # Stop protecting any newly-created instances from scaling in
  aws autoscaling update-auto-scaling-group --auto-scaling-group-name ${ASG_NAME} --no-new-instances-protected-from-scale-in
  # Remove scaling in protection from all the instances in the group
  PROTECTED_INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name ${ASG_NAME} --query "AutoScalingGroups[].Instances[].InstanceId" --output text)
  if [ -z "${PROTECTED_INSTANCE_IDS}" ]; then
    echo -n "Configuration of ASG set desired, minimum, maximum to 0. Don't need to restore original state after scaling in"
  else 
     aws autoscaling set-instance-protection --instance-ids ${PROTECTED_INSTANCE_IDS} --auto-scaling-group-name ${ASG_NAME} --no-protected-from-scale-in
  fi
}

help__mdcQualityGate="Check quality gate status"
task_mdcQualityGate() {
  local repo_name="$1"
  local branch="$2"
  assume_role $(account_id_for_name "cg-opsmo") "GoCDAssumedIamRole"
  local sonarSecret=$(aws secretsmanager get-secret-value --secret-id mdc_build/sonarcloud_token --query SecretString --output text --region ap-southeast-1)
  local statusResponse=$(curl -u "${sonarSecret}": https://sonarcloud.io/api/project_branches/list?project=${repo_name})
  echo "${statusResponse}"
  local projectStatus=$(echo "${statusResponse}" | jq '.branches | .[] | {name: .name, status: .status.qualityGateStatus} | select(.name=="'${branch}'") | .status')
  echo "qualitygate status of repo: "${repo_name} " branch: " ${branch} " is " ${projectStatus}
  if [[ ${projectStatus} == "\"OK\"" ]] ;
  then
    echo "Quality gate passed"
  else
    echo "Quality gate failed!"
    exit 1
  fi
}

list_all_helps() {
  compgen -v | grep -E "^help__.*"
}

NEW_LINE=$'\n'
if type -t "task_$TASK" &>/dev/null; then
  task_$TASK $ARGS
else
  echo "usage: $0 <task> [<..args>]"
  echo "task:"

  HELPS=""
  for help in $(list_all_helps); do

    HELPS="$HELPS    ${help/help__/} |-- ${!help}$NEW_LINE"
  done

  echo "$HELPS" | column -t -s "|"
  exit 1
fi
